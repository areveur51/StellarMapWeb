{% load static %}

<!DOCTYPE html>
<html>
<head>
  <title>StellarMap Web</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <!-- Global theme loader - syncs with admin portal theme -->
  <script src="{% static 'webApp/js/global_theme_loader.js' %}"></script>
  <script src="{% static 'webApp/js/theme_sync.js' %}"></script>
  <!-- include custom theme -->
  <link rel="stylesheet" type="text/css" href="{% static 'webApp/css/frontend.css' %}">
  <!-- Shared visualization controls CSS -->
  <link rel="stylesheet" href="{% static 'radialTidyTreeApp/css/visualization_controls.css' %}">
  <!-- include the Font Awesome library for the search icon -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" crossorigin="anonymous">
  <!-- include HighlightJS library for the terminal text fields -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/monokai-sublime.min.css" crossorigin="anonymous">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js" crossorigin="anonymous"></script>
  
  <!-- Toggle active state CSS -->
  <style>
    .toggle-switch.active .toggle-slider {
      transform: translateX(32px) !important;
      background: linear-gradient(135deg, #0BE784, #96DDF2) !important;
    }
    
    /* Logs Display Styling - High Contrast for Cyberpunk Theme */
    .logs-display {
      max-height: 600px;
      overflow-y: auto;
      background-color: #1a1a2e !important;
      color: #00ff88 !important;
      padding: 15px;
      border-radius: 5px;
      border: 1px solid #0BE784;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.5;
    }
    
    /* Override highlight.js colors for better visibility */
    .logs-display .hljs-string,
    .logs-display .hljs-variable,
    .logs-display .hljs-title,
    .logs-display .hljs-keyword {
      color: #0BE784 !important;
    }
    
    .logs-display .hljs-number,
    .logs-display .hljs-built_in {
      color: #96DDF2 !important;
    }
    
    .logs-display .hljs-comment {
      color: #888 !important;
    }
    
    /* Error Logs - Red/Orange Theme for Errors */
    .logs-display.error-logs {
      border-color: #ff6b6b;
      color: #ff6b6b !important;
    }
    
    .logs-display.error-logs .hljs-string,
    .logs-display.error-logs .hljs-variable,
    .logs-display.error-logs .hljs-title,
    .logs-display.error-logs .hljs-keyword {
      color: #ff6b6b !important;
    }
    
    .logs-display.error-logs .hljs-number,
    .logs-display.error-logs .hljs-built_in {
      color: #ffa500 !important;
    }
  </style>
</head>
<body class="bg-color-261D45">
  <!-- No CSS overrides - use styling from visualization_toggle_include.html for DRY -->
  
  <!-- Scroll Position Save/Restore (on page navigation only, not on Vue updates) -->
  <script>
    // Save scroll position when user navigates away
    window.addEventListener('beforeunload', function() {
      sessionStorage.setItem('scrollPosition', window.scrollY || window.pageYOffset);
    });
    
    // Restore scroll position only on initial page load (not on Vue updates)
    window.addEventListener('load', function() {
      const savedScrollPosition = sessionStorage.getItem('scrollPosition');
      if (savedScrollPosition !== null && savedScrollPosition !== '0') {
        window.scrollTo({
          top: parseInt(savedScrollPosition),
          behavior: 'instant'
        });
        // Clear the saved position after restoration
        sessionStorage.removeItem('scrollPosition');
      }
    });
  </script>
  
  <div id="app">
    <!-- Include shared search container and sidebar -->
    {% include 'webApp/search_container_include.html' %}

    <!-- This element serves as a container for displaying the results of the search function -->
    <div class="results-container">
      {% if is_cached or is_refreshing %}
        <div class="cache-status-indicator" style="text-align: center; padding: 10px; margin-bottom: 10px;">
          {% if is_cached %}
            <span class="badge badge-success" style="font-size: 0.9em;">
              <i class="fas fa-clock"></i> Cached Data (Fresh)
            </span>
          {% elif is_refreshing %}
            <span class="badge badge-warning" style="font-size: 0.9em;">
              <i class="fas fa-sync fa-spin"></i> Refreshing Data...
            </span>
          {% endif %}
        </div>
      {% endif %}
      <div class="response-container" style="position: relative;">
        <!-- Include visualization controls next to the tree -->
        {% include 'radialTidyTreeApp/visualization_toggle_include.html' %}
        
        <div class="radial-tree-visual">
          {% include "radialTidyTreeApp/radial_tidy_tree_partial.html" %}
        </div>

        <div>
          <b-card no-body class="bv-tabs">
            <b-tabs card @input="onTabChange">
              <b-tab title="Account Lineage" active :title-link-attributes="{ title: 'View lineage table leading back to origin/creator accounts' }">
                <template>
                  <div v-if="lineageLoading" style="text-align: center; padding: 20px;">
                    <b-spinner variant="primary"></b-spinner>
                    <p>Loading account lineage...</p>
                  </div>
                  <div v-else-if="lineageError" class="alert alert-danger">
                    {% verbatim %}{{ lineageError }}{% endverbatim %}
                  </div>
                  <div v-else-if="account_lineage_data && account_lineage_data.length > 0">
                    <b-table
                      :items="account_lineage_data"
                      :fields="lineageTableFields"
                      striped
                      small
                      dark
                      hover
                    >
                      <template #cell(stellar_account)="data">
                        {% verbatim %}<span 
                          v-if="data.value"
                          style="font-family: monospace; font-size: 0.85em; cursor: pointer;"
                          :title="data.value"
                          @dblclick="copyToClipboard(data.value, 'Account address copied!')"
                        >...{{ data.value.slice(-7) }}</span>{% endverbatim %}
                        <span v-else class="text-muted">-</span>
                      </template>
                      <template #cell(stellar_creator_account)="data">
                        {% verbatim %}<span 
                          v-if="data.value"
                          style="font-family: monospace; font-size: 0.85em; cursor: pointer;"
                          :title="data.value"
                          @dblclick="copyToClipboard(data.value, 'Creator address copied!')"
                        >...{{ data.value.slice(-7) }}</span>{% endverbatim %}
                        <span v-else class="text-muted">-</span>
                      </template>
                      <template #cell(xlm_balance)="data">
                        {% verbatim %}{{ data.value ? data.value.toFixed(3) : '0.000' }} XLM{% endverbatim %}
                      </template>
                      <template #cell(assets)="row">
                        {% verbatim %}<span v-if="row.item.assets && row.item.assets.length > 0">
                          <b-badge variant="success">{{ row.item.assets.length }}</b-badge>
                        </span>{% endverbatim %}
                        <span v-else class="text-muted">0</span>
                      </template>
                      <template #cell(se_url)="row">
                        {% verbatim %}<a 
                          v-if="row.item.stellar_account && row.item.network_name"
                          :href="'https://stellar.expert/explorer/' + row.item.network_name + '/account/' + row.item.stellar_account"
                          target="_blank"
                          rel="noopener noreferrer"
                          title="View on Stellar Expert"
                          class="btn btn-sm btn-outline-primary"
                        >
                          <i class="fas fa-external-link-alt"></i>
                        </a>{% endverbatim %}
                        <span v-else class="text-muted">-</span>
                      </template>
                      <template #cell(stellar_account_created_at)="data">
                        {% verbatim %}<span v-if="data.value">{{ formatDateTimeEST(data.value) }}</span>{% endverbatim %}
                        <span v-else class="text-muted">-</span>
                      </template>
                      <template #cell(created_at)="data">
                        {% verbatim %}<span v-if="data.value">{{ formatDateTimeEST(data.value) }}</span>{% endverbatim %}
                        <span v-else class="text-muted">-</span>
                      </template>
                      <template #cell(updated_at)="data">
                        {% verbatim %}<span v-if="data.value">{{ formatDateTimeEST(data.value) }}</span>{% endverbatim %}
                        <span v-else class="text-muted">-</span>
                      </template>
                      <template #cell(home_domain)="data">
                        {% verbatim %}<a 
                          v-if="data.value && data.value.trim()"
                          href="#"
                          @click.prevent="showTomlContent(data.value)"
                          :title="'TOML: https://' + data.value + '/.well-known/stellar.toml'"
                          style="cursor: pointer; text-decoration: underline;"
                        >{{ data.value }}</a>{% endverbatim %}
                        <span v-else class="text-muted">-</span>
                      </template>
                      <template #cell(status)="row">
                        {% verbatim %}<b-badge 
                          :variant="getLineageStatusVariant(row.item.status)"
                          :style="row.item.status === 'FAILED' ? 'cursor: pointer;' : ''"
                          :title="row.item.status === 'FAILED' ? 'Click to retry' : ''"
                          @click="row.item.status === 'FAILED' ? retryFailedAccount(row.item) : null"
                        >{{ row.item.status }}</b-badge>{% endverbatim %}
                      </template>
                      <template #cell(actions)="row">
                        <b-button size="sm" variant="info" @click="showLineageJson(row.item)" title="View JSON">
                          <i class="fas fa-code"></i>
                        </b-button>
                      </template>
                    </b-table>
                  </div>
                  <div v-else class="alert alert-info">
                    No lineage data available for this address.
                  </div>
                </template>
              </b-tab>
              <b-tab title="Tree Data" :title-link-attributes="{ title: 'Raw JSON data structure used to render the radial tidy tree visualization' }">
                <pre v-html="highlightedJSONResponse"></pre>
              </b-tab>
              <b-tab title="Search Cache" :title-link-attributes="{ title: 'Cache status and metadata for this search' }">
                <pre v-html="highlightedRequestStatus"></pre>
              </b-tab>
              <b-tab title="Pending Accounts" :title-link-attributes="{ title: 'Accounts currently being processed by the pipeline' }">
                <pre v-html="highlightedPendingAccounts"></pre>
              </b-tab>
              <b-tab title="Stages" :title-link-attributes="{ title: 'Real-time pipeline stage execution progress' }">
                <template>
                  <div v-if="stageExecutionsLoading" style="text-align: center; padding: 20px;">
                    <b-spinner variant="primary"></b-spinner>
                    <p>Loading stage executions...</p>
                  </div>
                  <div v-else-if="stageExecutionsError" class="alert alert-danger">
                    {{ stageExecutionsError }}
                  </div>
                  <div v-else-if="stage_executions_data && stage_executions_data.stages && stage_executions_data.stages.length > 0">
                    <b-table
                      :items="stage_executions_data.stages"
                      :fields="stageExecutionFields"
                      striped
                      small
                      dark
                      hover
                    >
                      <template #cell(status)="data">
                        <b-badge :variant="getStatusVariant(data.item.status)">{{ data.item.status }}</b-badge>
                      </template>
                      <template #cell(execution_time_seconds)="data">
                        {{ data.item.execution_time_seconds }}s
                      </template>
                      <template #cell(error_message)="data">
                        <span v-if="data.value" class="text-danger" v-text="truncateText(data.value, 50)"></span>
                        <span v-else class="text-success">No errors</span>
                      </template>
                      <template #cell(actions)="row">
                        <b-button size="sm" variant="info" @click="showStageJson(row.item)" title="View JSON">
                          <i class="fas fa-code"></i>
                        </b-button>
                      </template>
                    </b-table>
                    <div class="text-muted" style="font-size: 0.8em; margin-top: 10px;">
                      Auto-refreshes every 5 seconds
                    </div>
                  </div>
                  <div v-else class="alert alert-info">
                    No stage execution data available for this address. Stages will appear once processing begins.
                  </div>
                </template>
              </b-tab>
              <b-tab title="Logs" :title-link-attributes="{ title: 'Latest 1700 lines from Django Server logs' }">
                <template>
                  <div v-if="logsLoading" style="text-align: center; padding: 20px;">
                    <b-spinner variant="primary"></b-spinner>
                    <p>Loading logs...</p>
                  </div>
                  <div v-else-if="logsError" class="alert alert-danger">
                    {{ logsError }}
                  </div>
                  <div v-else>
                    <pre v-html="highlightedLogs" class="logs-display"></pre>
                  </div>
                </template>
              </b-tab>
              <b-tab title="Error Logs" :title-link-attributes="{ title: 'Latest 710 error/warning lines from Django Server logs' }">
                <template>
                  <div v-if="errorLogsLoading" style="text-align: center; padding: 20px;">
                    <b-spinner variant="danger"></b-spinner>
                    <p>Loading error logs...</p>
                  </div>
                  <div v-else-if="errorLogsError" class="alert alert-danger">
                    {{ errorLogsError }}
                  </div>
                  <div v-else-if="!highlightedErrorLogs || highlightedErrorLogs.trim() === ''" class="alert alert-success">
                    <strong>No errors found!</strong> Your server is running smoothly.
                  </div>
                  <div v-else>
                    <pre v-html="highlightedErrorLogs" class="logs-display error-logs"></pre>
                  </div>
                </template>
              </b-tab>
            </b-tabs>
          </b-card>
        </div>

      </div>
    </div>

    {% verbatim %}
    <!-- Stage JSON Viewer Modal -->
    <b-modal
      v-model="showStageJsonModal"
      title="Stage Execution Data"
      size="lg"
      ok-only
      ok-title="Close"
      header-bg-variant="dark"
      header-text-variant="light"
      body-bg-variant="dark"
      body-text-variant="light"
      footer-bg-variant="dark"
      footer-text-variant="light"
    >
      <div v-if="selectedStageData">
        <pre v-html="highlightedStageJSON" style="background-color: #23241f; padding: 15px; border-radius: 5px; max-height: 500px; overflow-y: auto;"></pre>
      </div>
    </b-modal>

    <!-- Lineage JSON Viewer Modal -->
    <b-modal
      v-model="showLineageJsonModal"
      title="Account Lineage Data"
      size="lg"
      ok-only
      ok-title="Close"
      header-bg-variant="dark"
      header-text-variant="light"
      body-bg-variant="dark"
      body-text-variant="light"
      footer-bg-variant="dark"
      footer-text-variant="light"
    >
      <div v-if="selectedLineageData">
        <pre v-html="highlightedLineageJSON" style="background-color: #23241f; padding: 15px; border-radius: 5px; max-height: 500px; overflow-y: auto;"></pre>
      </div>
    </b-modal>

    <!-- TOML Content Viewer Modal -->
    <b-modal
      v-model="showTomlModal"
      :title="tomlModalTitle"
      size="lg"
      ok-only
      ok-title="Close"
      header-bg-variant="dark"
      header-text-variant="light"
      body-bg-variant="dark"
      body-text-variant="light"
      footer-bg-variant="dark"
      footer-text-variant="light"
    >
      <div v-if="tomlLoading" class="text-center">
        <b-spinner variant="primary"></b-spinner>
        <p class="mt-3">Loading TOML content...</p>
      </div>
      <div v-else-if="tomlError" class="alert alert-danger">
        {{ tomlError }}
      </div>
      <div v-else-if="tomlContent">
        <pre style="background-color: #23241f; color: #e0e0e0; padding: 15px; border-radius: 5px; max-height: 500px; overflow-y: auto; white-space: pre-wrap; word-wrap: break-word;">{{ tomlContent }}</pre>
      </div>
    </b-modal>
    {% endverbatim %}
  </div>

  <!-- Load required Bootstrap and BootstrapVue CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-vue@2.23.1/dist/bootstrap-vue.min.css" crossorigin="anonymous">
  <!-- Load Vue followed by BootstrapVue -->
  <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap-vue@2.23.1/dist/bootstrap-vue.min.js" crossorigin="anonymous"></script>
  <!-- Load D3.js for visualization -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js" crossorigin="anonymous"></script>
  <!-- Load tidytree.js for radial tree rendering -->
  <script src="{% static 'radialTidyTreeApp/d3-3.2.2/tidytree.js' %}"></script>
  <!-- Custom VueJS mixin -->
  {{ tree_data|json_script:"tree-data-json" }}
  {{ account_genealogy_items|json_script:"account-genealogy-json" }}
  {{ request_status_data|json_script:"request-status-json" }}
  {{ account_lineage_data|json_script:"account-lineage-json" }}
  {{ pending_accounts_data|json_script:"pending-accounts-json" }}
  
  <script src="{% static 'webApp/js/lineage_table_mixin.js' %}?v=2"></script>
  <script>
    const treeDataEl = document.getElementById('tree-data-json');
    const genealogyEl = document.getElementById('account-genealogy-json');
    const requestStatusEl = document.getElementById('request-status-json');
    const accountLineageEl = document.getElementById('account-lineage-json');
    const pendingAccountsEl = document.getElementById('pending-accounts-json');
    const parsedTreeData = JSON.parse(treeDataEl.textContent || '{}');
    const parsedRequestStatus = JSON.parse(requestStatusEl.textContent || '{}');
    const parsedAccountLineage = JSON.parse(accountLineageEl.textContent || '[]');
    const parsedPendingAccounts = JSON.parse(pendingAccountsEl.textContent || '[]');
    
    // Register BootstrapVue with Vue
    Vue.use(BootstrapVue);
    
    // Use window.currentTreeData for true global scope (accessible across all scripts)
    if (typeof window.currentTreeData === 'undefined') {
        window.currentTreeData = null;
    }
    
    // Wait for shared visualization component to load, then check if we need to restore tidy mode
    window.addEventListener('DOMContentLoaded', function() {
        // Check saved visualization mode
        const savedMode = localStorage.getItem('visualizationMode') || 'radial';
        
        if (savedMode === 'tidy') {
            console.log('DOMContentLoaded: Restored tidy tree mode from localStorage');
            
            // Wait for tree data to be available, then render in tidy mode
            let attempts = 0;
            const maxAttempts = 50; // 5 seconds max (50 * 100ms)
            const checkAndRenderTidy = () => {
                if (window.currentTreeData && typeof renderTidyTree === 'function') {
                    renderTidyTree(window.currentTreeData);
                    console.log('DOMContentLoaded: Re-rendered tree in tidy mode');
                } else if (attempts < maxAttempts) {
                    attempts++;
                    setTimeout(checkAndRenderTidy, 100);
                } else {
                    console.warn('DOMContentLoaded: Timed out waiting for tree data or renderTidyTree function');
                }
            };
            checkAndRenderTidy();
        } else {
            console.log('DOMContentLoaded: Using radial mode (default or from localStorage)');
        }
    });
    
    var vm = new Vue({
        el: '#app',
        mixins: [lineage_table_mixin],
        data: {
          query_account: '{{ account|default:"GD6WU64OEP5C4LRBH6NK3MHYIA2ADN6K6II6EXPNVUR3ERBXT4AN4ACD" }}',
          loading: false,
          progressValue: 0,
          response: '',
          highlightedJSONResponse: '',
          highlightedRequestStatus: '',
          highlightedAccountLineage: '',
          highlightedPendingAccounts: '',
          highlightedLogs: '',
          network_toggle: {% if network == 'testnet' %}false{% else %}true{% endif %},
          network_selected: '{{ network|default:"public" }}',
          loading_animation: true,
          account_genealogy_items: JSON.parse(genealogyEl.textContent || '[]'),
          tree_data: parsedTreeData,
          request_status_data: parsedRequestStatus,
          account_lineage_data: parsedAccountLineage,
          pending_accounts_data: parsedPendingAccounts,
          pendingAccountsInterval: null,
          stage_executions_data: { stages: [] },
          stageExecutionsLoading: false,
          stageExecutionsError: null,
          logsLoading: false,
          logsError: null,
          errorLogsLoading: false,
          errorLogsError: null,
          highlightedErrorLogs: '',
          stageExecutionsInterval: null,
          lineageLoading: false,
          lineageError: null,
          lineageInterval: null,
          stageExecutionFields: [
            { key: 'stage_number', label: 'Stage', sortable: true },
            { key: 'cron_name', label: 'Cron Job', sortable: true },
            { key: 'status', label: 'Status', sortable: true },
            { key: 'execution_time_seconds', label: 'Time', sortable: true },
            { key: 'error_message', label: 'Error', sortable: false },
            { key: 'actions', label: 'JSON', sortable: false }
          ],
          lineageTableFields: [
            { key: 'stellar_account', label: 'Account', sortable: true },
            { key: 'stellar_creator_account', label: 'Creator Account', sortable: true },
            { key: 'network_name', label: 'Network', sortable: true },
            { key: 'stellar_account_created_at', label: 'Account Created', sortable: true },
            { key: 'home_domain', label: 'Home Domain', sortable: true },
            { key: 'xlm_balance', label: 'XLM Balance', sortable: true },
            { key: 'assets', label: 'Assets', sortable: true },
            { key: 'se_url', label: 'SE URL', sortable: false },
            { key: 'status', label: 'Status', sortable: true },
            { key: 'created_at', label: 'Pipeline Created', sortable: true },
            { key: 'updated_at', label: 'Pipeline Updated', sortable: true },
            { key: 'actions', label: 'JSON', sortable: false }
          ],
          showStageJsonModal: false,
          selectedStageData: null,
          highlightedStageJSON: '',
          showLineageJsonModal: false,
          selectedLineageData: null,
          highlightedLineageJSON: '',
          showTomlModal: false,
          tomlModalTitle: '',
          tomlContent: '',
          tomlLoading: false,
          tomlError: null
        },
      methods: {
        async search() {
          // Set 'loading' to true to show a loading indicator
          this.loading = true;
          this.progressValue = 17;
          
          try {
            // Use Django backend for efficient search with caching and validation
            const searchUrl = `/search/?account=${encodeURIComponent(this.query_account)}&network=${this.network_selected}`;
            window.location.href = searchUrl;
          } catch (e) {
            // If an error occurs, store the error message in 'response'
            this.response = e.message;
            this.loading = false;
          }
        },
        toggleNetwork() {
          // Method that toggles the value of 'network_selected' between 'testnet' and 'public'
          this.network_selected = this.network_toggle ? 'public' : 'testnet'
        },
        updateJSONDisplay() {
          let dataToDisplay = null;
          
          if (this.account_genealogy_items && this.account_genealogy_items.length > 0) {
            dataToDisplay = this.account_genealogy_items;
          } else if (this.tree_data && Object.keys(this.tree_data).length > 0) {
            dataToDisplay = this.tree_data;
          }
          
          if (dataToDisplay) {
            this.response = JSON.stringify(dataToDisplay, null, 2);
            try {
              if (typeof hljs !== 'undefined') {
                this.highlightedJSONResponse = hljs.highlight(this.response, {language: 'json'}).value;
              } else {
                this.highlightedJSONResponse = this.response;
              }
            } catch (e) {
              this.highlightedJSONResponse = this.response;
            }
          } else {
            this.response = '';
            this.highlightedJSONResponse = '';
          }
        },
        updateRequestStatusDisplay() {
          if (this.request_status_data && Object.keys(this.request_status_data).length > 0) {
            const statusJSON = JSON.stringify(this.request_status_data, null, 2);
            try {
              if (typeof hljs !== 'undefined') {
                this.highlightedRequestStatus = hljs.highlight(statusJSON, {language: 'json'}).value;
              } else {
                this.highlightedRequestStatus = statusJSON;
              }
            } catch (e) {
              this.highlightedRequestStatus = statusJSON;
            }
          } else {
            this.highlightedRequestStatus = '';
          }
        },
        updateAccountLineageDisplay() {
          if (this.account_lineage_data && this.account_lineage_data.length > 0) {
            const lineageJSON = JSON.stringify(this.account_lineage_data, null, 2);
            try {
              if (typeof hljs !== 'undefined') {
                this.highlightedAccountLineage = hljs.highlight(lineageJSON, {language: 'json'}).value;
              } else {
                this.highlightedAccountLineage = lineageJSON;
              }
            } catch (e) {
              this.highlightedAccountLineage = lineageJSON;
            }
            
            // Transform lineage data to tree structure and update visualization
            this.buildTreeFromLineage();
          } else {
            this.highlightedAccountLineage = '';
          }
        },
        buildTreeFromLineage() {
          if (!this.account_lineage_data || this.account_lineage_data.length === 0) {
            return;
          }
          
          // Build a map of accounts for easy lookup
          const accountMap = new Map();
          
          // First pass: create all nodes
          this.account_lineage_data.forEach(record => {
            accountMap.set(record.stellar_account, {
              name: record.stellar_account,
              node_type: 'ISSUER',
              stellar_account: record.stellar_account,
              created: record.stellar_account_created_at || '',
              home_domain: record.home_domain || '',
              xlm_balance: record.xlm_balance || 0,
              creator_account: record.stellar_creator_account || '',
              children: []
            });
          });
          
          // Second pass: build the tree structure showing both directions
          let rootNode = null;
          this.account_lineage_data.forEach(record => {
            const currentNode = accountMap.get(record.stellar_account);
            const creatorAccount = record.stellar_creator_account;
            
            // Build creator chain (upward): add as child of creator
            if (creatorAccount && accountMap.has(creatorAccount)) {
              const parentNode = accountMap.get(creatorAccount);
              // Only add if not already a child (avoid duplicates)
              if (!parentNode.children.some(child => child.stellar_account === currentNode.stellar_account)) {
                parentNode.children.push(currentNode);
              }
            } else {
              // No creator in dataset means this is a potential root
              if (!rootNode) {
                rootNode = currentNode;
              }
            }
            
            // Build descendant chain (downward): add child accounts created by this account
            if (record.child_accounts && record.child_accounts.length > 0) {
              record.child_accounts.forEach(childAccount => {
                if (accountMap.has(childAccount)) {
                  const childNode = accountMap.get(childAccount);
                  // Only add if not already a child (avoid duplicates)
                  if (!currentNode.children.some(child => child.stellar_account === childNode.stellar_account)) {
                    currentNode.children.push(childNode);
                  }
                }
              });
            }
            
            // Add ASSET nodes as children of this ISSUER node
            if (record.assets && record.assets.length > 0) {
              record.assets.forEach(asset => {
                currentNode.children.push({
                  name: asset.asset_code,
                  node_type: 'ASSET',
                  asset_type: asset.asset_type,
                  asset_code: asset.asset_code,
                  asset_issuer: asset.asset_issuer,
                  balance: asset.balance,
                  children: []
                });
              });
            }
          });
          
          // Fallback to first account if still no root
          if (!rootNode && this.account_lineage_data.length > 0) {
            rootNode = accountMap.get(this.account_lineage_data[0].stellar_account);
          }
          
          // Update tree_data and trigger visualization
          if (rootNode) {
            this.tree_data = rootNode;
            
            // Trigger tree rendering if renderRadialTree function exists
            this.$nextTick(() => {
              // Ensure spacing multiplier is loaded from localStorage before rendering
              const savedSpacing = localStorage.getItem('nodeSpacingMultiplier');
              const parsedSpacing = parseFloat(savedSpacing);
              if (!isNaN(parsedSpacing) && parsedSpacing >= 0.5 && parsedSpacing <= 2.0) {
                window.nodeSpacingMultiplier = parsedSpacing;
              }
              
              // Update currentTreeData for slider re-renders
              window.currentTreeData = this.tree_data;
              
              if (typeof renderRadialTree === 'function') {
                renderRadialTree(this.tree_data);
              }
            });
          }
        },
        updatePendingAccountsDisplay() {
          const pendingJSON = JSON.stringify(this.pending_accounts_data || [], null, 2);
          try {
            if (typeof hljs !== 'undefined') {
              this.highlightedPendingAccounts = hljs.highlight(pendingJSON, {language: 'json'}).value;
            } else {
              this.highlightedPendingAccounts = pendingJSON;
            }
          } catch (e) {
            this.highlightedPendingAccounts = pendingJSON;
          }
        },
        async fetchPendingAccounts() {
          try {
            const response = await fetch('/api/pending-accounts/');
            if (response.ok) {
              const data = await response.json();
              // Handle new response format: {accounts: [...], count: X, total_pending: Y}
              this.pending_accounts_data = data.accounts || data;
            }
          } catch (e) {
            console.error('Error fetching pending accounts:', e);
          }
        },
        async fetchStageExecutions() {
          if (!this.query_account || !this.network_selected) {
            return;
          }
          
          const isFirstLoad = this.stageExecutionsLoading && !this.stage_executions_data.stages;
          
          try {
            // Only show loading spinner on first load
            if (isFirstLoad) {
              this.stageExecutionsLoading = true;
            }
            this.stageExecutionsError = null;
            
            const url = `/api/stage-executions/?account=${encodeURIComponent(this.query_account)}&network=${encodeURIComponent(this.network_selected)}`;
            const response = await fetch(url);
            
            if (response.ok) {
              const data = await response.json();
              this.stage_executions_data = data;
            } else {
              const error = await response.json();
              this.stageExecutionsError = error.message || 'Failed to fetch stage executions';
            }
          } catch (e) {
            console.error('Error fetching stage executions:', e);
            this.stageExecutionsError = 'Error fetching stage executions';
          } finally {
            this.stageExecutionsLoading = false;
          }
        },
        async fetchAccountLineage() {
          if (!this.query_account || !this.network_selected) {
            return;
          }
          
          const isFirstLoad = !this.account_lineage_data || this.account_lineage_data.length === 0;
          
          try {
            // Only show loading spinner on first load
            if (isFirstLoad) {
              this.lineageLoading = true;
            }
            this.lineageError = null;
            
            const url = `/api/account-lineage/?account=${encodeURIComponent(this.query_account)}&network=${encodeURIComponent(this.network_selected)}`;
            const response = await fetch(url);
            
            if (response.ok) {
              const data = await response.json();
              this.account_lineage_data = data.lineage;
            } else {
              const error = await response.json();
              this.lineageError = error.message || 'Failed to fetch account lineage';
            }
          } catch (e) {
            console.error('Error fetching account lineage:', e);
            this.lineageError = 'Error fetching account lineage';
          } finally {
            this.lineageLoading = false;
          }
        },
        async fetchServerLogs() {
          try {
            this.logsLoading = true;
            this.logsError = null;
            
            const response = await fetch('/api/server-logs/');
            
            if (response.ok) {
              const data = await response.json();
              // Highlight logs using same format as Tree Data
              try {
                if (typeof hljs !== 'undefined') {
                  this.highlightedLogs = hljs.highlight(data.logs, {language: 'shell'}).value;
                } else {
                  this.highlightedLogs = data.logs;
                }
              } catch (e) {
                this.highlightedLogs = data.logs;
              }
            } else {
              const error = await response.json();
              this.logsError = error.error || 'Failed to fetch logs';
            }
          } catch (e) {
            console.error('Error fetching server logs:', e);
            this.logsError = 'Error fetching server logs';
          } finally {
            this.logsLoading = false;
          }
        },
        async fetchErrorLogs() {
          try {
            this.errorLogsLoading = true;
            this.errorLogsError = null;
            
            const response = await fetch('/api/error-logs/');
            
            if (response.ok) {
              const data = await response.json();
              // Highlight error logs using shell syntax
              try {
                if (typeof hljs !== 'undefined') {
                  this.highlightedErrorLogs = hljs.highlight(data.logs, {language: 'shell'}).value;
                } else {
                  this.highlightedErrorLogs = data.logs;
                }
              } catch (e) {
                this.highlightedErrorLogs = data.logs;
              }
            } else {
              const error = await response.json();
              this.errorLogsError = error.error || 'Failed to fetch error logs';
            }
          } catch (e) {
            console.error('Error fetching error logs:', e);
            this.errorLogsError = 'Error fetching error logs';
          } finally {
            this.errorLogsLoading = false;
          }
        },
        onTabChange(tabIndex) {
          // Tab indices: 0=Account Lineage, 1=Tree Data, 2=Pending Accounts, 3=Stages, 4=Logs, 5=Error Logs
          if (tabIndex === 4) {
            // Logs tab selected
            this.fetchServerLogs();
          } else if (tabIndex === 5) {
            // Error Logs tab selected
            this.fetchErrorLogs();
          }
        },
        getStatusVariant(status) {
          if (status === 'SUCCESS') return 'success';
          if (status === 'FAILED' || status === 'ERROR') return 'danger';
          if (status === 'TIMEOUT') return 'warning';
          return 'secondary';
        },
        truncateText(text, length) {
          if (!text) return '';
          if (text.length <= length) return text;
          return text.substring(0, length) + '...';
        },
        showStageJson(stageData) {
          this.selectedStageData = stageData;
          const stageJSON = JSON.stringify(stageData, null, 2);
          try {
            if (typeof hljs !== 'undefined') {
              this.highlightedStageJSON = hljs.highlight(stageJSON, {language: 'json'}).value;
            } else {
              this.highlightedStageJSON = stageJSON;
            }
          } catch (e) {
            this.highlightedStageJSON = stageJSON;
          }
          this.showStageJsonModal = true;
        },
        showLineageJson(lineageData) {
          this.selectedLineageData = lineageData;
          const lineageJSON = JSON.stringify(lineageData, null, 2);
          try {
            if (typeof hljs !== 'undefined') {
              this.highlightedLineageJSON = hljs.highlight(lineageJSON, {language: 'json'}).value;
            } else {
              this.highlightedLineageJSON = lineageJSON;
            }
          } catch (e) {
            this.highlightedLineageJSON = lineageJSON;
          }
          this.showLineageJsonModal = true;
        },
        getLineageStatusVariant(status) {
          if (!status) return 'secondary';
          // Normalize to uppercase for case-insensitive matching
          const statusUpper = status.toUpperCase();
          
          // Success statuses (DONE_* indicates completion)
          if (statusUpper.includes('DONE_') || statusUpper === 'COMPLETED' || statusUpper === 'COMPLETED_SUCCESS') return 'success';
          // Error statuses
          if (statusUpper === 'FAILED' || statusUpper === 'ERROR' || statusUpper.includes('INVALID')) return 'danger';
          // Warning statuses
          if (statusUpper === 'PENDING_HORIZON_API_DATASETS' || statusUpper === 'RE_INQUIRY') return 'warning';
          // In-progress and pending statuses
          if (statusUpper.includes('PENDING') || statusUpper.includes('IN_PROGRESS')) return 'info';
          return 'secondary';
        },
        formatDateTimeEST(dateString) {
          if (!dateString) return '-';
          
          try {
            const date = new Date(dateString);
            
            // Format to NY EST timezone
            const options = {
              timeZone: 'America/New_York',
              year: 'numeric',
              month: '2-digit',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit',
              hour12: false
            };
            
            return date.toLocaleString('en-US', options);
          } catch (e) {
            console.error('Error formatting date:', e);
            return dateString;
          }
        },
        copyToClipboard(text, message = 'Copied to clipboard!') {
          if (!text) return;
          
          // Use the modern Clipboard API if available
          if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(text).then(() => {
              this.$bvToast.toast(message, {
                title: 'Success',
                variant: 'success',
                solid: true,
                autoHideDelay: 2000
              });
            }).catch(err => {
              console.error('Failed to copy:', err);
              this.fallbackCopyToClipboard(text, message);
            });
          } else {
            this.fallbackCopyToClipboard(text, message);
          }
        },
        fallbackCopyToClipboard(text, message) {
          // Fallback for older browsers
          const textArea = document.createElement('textarea');
          textArea.value = text;
          textArea.style.position = 'fixed';
          textArea.style.left = '-999999px';
          document.body.appendChild(textArea);
          textArea.select();
          
          try {
            document.execCommand('copy');
            this.$bvToast.toast(message, {
              title: 'Success',
              variant: 'success',
              solid: true,
              autoHideDelay: 2000
            });
          } catch (err) {
            console.error('Failed to copy:', err);
            this.$bvToast.toast('Failed to copy to clipboard', {
              title: 'Error',
              variant: 'danger',
              solid: true,
              autoHideDelay: 2000
            });
          }
          
          document.body.removeChild(textArea);
        },
        async showTomlContent(homeDomain) {
          if (!homeDomain) return;
          
          // Reset state
          this.tomlContent = '';
          this.tomlError = null;
          this.tomlLoading = true;
          this.tomlModalTitle = `Stellar TOML: ${homeDomain}`;
          this.showTomlModal = true;
          
          const proxyUrl = `/api/fetch-toml/?domain=${encodeURIComponent(homeDomain)}`;
          
          try {
            const response = await fetch(proxyUrl);
            const data = await response.json();
            
            if (!response.ok) {
              throw new Error(data.error || `Failed to fetch TOML: ${response.status}`);
            }
            
            this.tomlContent = data.content;
          } catch (error) {
            console.error('Error fetching TOML:', error);
            this.tomlError = `Failed to load TOML file for ${homeDomain}. ${error.message}`;
          } finally {
            this.tomlLoading = false;
          }
        },
        async retryFailedAccount(accountData) {
          if (!accountData || !accountData.stellar_account || !accountData.network_name) {
            console.error('Invalid account data for retry');
            return;
          }
          
          try {
            const url = '/api/retry-failed-account/';
            const formData = new FormData();
            formData.append('account', accountData.stellar_account);
            formData.append('network', accountData.network_name);
            
            const response = await fetch(url, {
              method: 'POST',
              body: formData,
              headers: {
                'X-CSRFToken': this.getCSRFToken()
              }
            });
            
            const data = await response.json();
            
            if (response.ok && data.success) {
              this.$bvToast.toast(`Account ${accountData.stellar_account.slice(-7)} queued for retry`, {
                title: 'Retry Initiated',
                variant: 'success',
                solid: true,
                autoHideDelay: 3000
              });
              
              // Update the status in the UI immediately
              accountData.status = 'RE_INQUIRY';
              
              // Refresh lineage data after a short delay
              setTimeout(() => {
                this.fetchAccountLineage();
              }, 1000);
            } else {
              throw new Error(data.error || 'Failed to retry account');
            }
          } catch (error) {
            console.error('Error retrying account:', error);
            this.$bvToast.toast(error.message || 'Failed to retry account', {
              title: 'Retry Failed',
              variant: 'danger',
              solid: true,
              autoHideDelay: 3000
            });
          }
        },
        getCSRFToken() {
          const name = 'csrftoken';
          let cookieValue = null;
          if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
              const cookie = cookies[i].trim();
              if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
              }
            }
          }
          return cookieValue;
        }
      },
      watch: {
        account_genealogy_items: {
          handler(newVal) {
            // Update JSON display whenever account_genealogy_items changes
            this.updateJSONDisplay();
          },
          deep: true,
          immediate: true
        },
        tree_data: {
          handler(newVal) {
            // Update JSON display whenever tree_data changes
            this.updateJSONDisplay();
          },
          deep: true,
          immediate: true
        },
        request_status_data: {
          handler(newVal) {
            // Update request status display whenever request_status_data changes
            this.updateRequestStatusDisplay();
          },
          deep: true,
          immediate: true
        },
        account_lineage_data: {
          handler(newVal) {
            // Update account lineage display whenever account_lineage_data changes
            this.updateAccountLineageDisplay();
          },
          deep: true,
          immediate: true
        },
        pending_accounts_data: {
          handler(newVal) {
            // Update pending accounts display whenever pending_accounts_data changes
            this.updatePendingAccountsDisplay();
          },
          deep: true,
          immediate: true
        }
      },
      mounted() {
        // Initialize based on URL parameters if available
        const urlParams = new URLSearchParams(window.location.search);
        const accountParam = urlParams.get('account');
        const networkParam = urlParams.get('network');
        
        if (accountParam) {
          this.query_account = accountParam;
        }
        if (networkParam) {
          this.network_selected = networkParam;
          this.network_toggle = networkParam === 'public';
        }
        
        // Fetch pending accounts immediately on mount
        this.fetchPendingAccounts();
        
        // Fetch server logs immediately on mount
        this.fetchServerLogs();
        
        // Set up auto-refresh for pending accounts every 15 seconds (optimized from 5s)
        this.pendingAccountsInterval = setInterval(() => {
          this.fetchPendingAccounts();
        }, 15000);
        
        // Fetch stage executions immediately if account is available
        if (this.query_account && this.network_selected) {
          this.fetchStageExecutions();
          
          // Set up auto-refresh for stage executions every 15 seconds (optimized from 5s)
          this.stageExecutionsInterval = setInterval(() => {
            this.fetchStageExecutions();
          }, 15000);
          
          // Fetch account lineage immediately on mount
          this.fetchAccountLineage();
          
          // Set up auto-refresh for account lineage every 15 seconds (optimized from 5s)
          this.lineageInterval = setInterval(() => {
            this.fetchAccountLineage();
          }, 15000);
        }
        
        // JSON display is automatically updated by the watcher
      },
      beforeDestroy() {
        // Clean up intervals when component is destroyed
        if (this.pendingAccountsInterval) {
          clearInterval(this.pendingAccountsInterval);
        }
        if (this.stageExecutionsInterval) {
          clearInterval(this.stageExecutionsInterval);
        }
        if (this.lineageInterval) {
          clearInterval(this.lineageInterval);
        }
      }
    })
  </script>
</body>
</html>